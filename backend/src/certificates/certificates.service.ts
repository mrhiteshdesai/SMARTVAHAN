import { Injectable, BadRequestException, NotFoundException, InternalServerErrorException, UnauthorizedException } from '@nestjs/common';
import { PrismaService } from '../prisma.service';
import * as fs from 'fs';
import * as path from 'path';
import * as PDFDocument from 'pdfkit';
import * as QRCode from 'qrcode';

@Injectable()
export class CertificatesService {
  constructor(private prisma: PrismaService) {}

  async validateQr(qrContent: string, user: any) {
    // Fetch full user/dealer details for authorization
    let dbUser: any = null;
    let authorizedState: string | null = null;
    let authorizedOems: string[] = []; // List of authorized OEM codes
    let isSuperAdmin = false;

    if (user.role === 'DEALER_USER' || user.role === 'DEALER') {
        dbUser = await this.prisma.dealer.findUnique({
            where: { id: user.userId },
            include: { oems: true }
        });
        if (!dbUser) throw new UnauthorizedException('Dealer account not found');
        if (dbUser.status !== 'ACTIVE') throw new UnauthorizedException('Dealer account is inactive');
        
        authorizedState = dbUser.stateCode;
        authorizedOems = dbUser.oems.map(o => o.code);
    } else {
        // System User
        dbUser = await this.prisma.user.findUnique({ where: { id: user.userId } });
        if (!dbUser) throw new UnauthorizedException('User account not found');
        
        if (dbUser.role === 'SUPER_ADMIN') {
            isSuperAdmin = true;
        } else if (dbUser.role === 'STATE_ADMIN') {
            authorizedState = dbUser.stateCode;
            // State Admin typically manages all OEMs in their state, or restricted?
            // Assuming full access within state unless oemCode is set
            if (dbUser.oemCode) authorizedOems = [dbUser.oemCode];
        } else if (dbUser.role === 'OEM_ADMIN') {
            if (dbUser.oemCode) authorizedOems = [dbUser.oemCode];
            if (dbUser.stateCode) authorizedState = dbUser.stateCode;
        }
    }

    // 1. Domain Validation
    // Validate {DOMAIN} embedded in QR
    let url: URL;
    try {
        url = new URL(qrContent);
    } catch (e) {
        // If not a URL, try to see if it's just the value (Legacy support or manual entry)
        // But user insists on Domain/State/Brand validation from QR content.
        // If it's just a value, we can't validate those without DB lookup.
        // However, we'll try to support legacy by skipping step 1-3 ONLY IF it looks like a value?
        // NO, User said "MANDATORY" sequence.
        // We will throw error if not a valid URL.
        throw new BadRequestException('Invalid QR Code Format: Not a valid URL');
    }

    const allowedDomains = [
        'smartvahan.com', 
        'www.smartvahan.com', 
        'localhost', 
        '127.0.0.1'
    ];
    // Add configured domain from env
    if (process.env.BASE_DOMAIN) allowedDomains.push(process.env.BASE_DOMAIN);

    const isDomainValid = allowedDomains.some(d => url.hostname.includes(d));
    if (!isDomainValid) {
         throw new BadRequestException('Invalid QR Code: Unauthorized Domain');
    }

    // Parse URL Structure: .../{STATE}/{OEM}/{PRODUCT}/qr={VALUE}
    // We expect at least 4 segments in path
    const pathParts = url.pathname.split('/').filter(p => p.length > 0);
    if (pathParts.length < 4) {
        throw new BadRequestException('Invalid QR Code Format: URL structure mismatch');
    }

    // Locate segments (Assuming standard structure generated by QrService)
    // Structure: uploads/QR/{STATE}/{OEM} -> This is for PDF file path.
    // QR Content URL: {Base}/{STATE}/{OEM}/{PRODUCT}/qr={VALUE}
    // So indices: 0=State, 1=OEM, 2=Product, 3=qr=Value (Last one)
    
    // We grab the last part for value, and 3 parts before it.
    const qrValuePart = pathParts[pathParts.length - 1];
    if (!qrValuePart.startsWith('qr=')) {
         throw new BadRequestException('Invalid QR Code Format: Missing qr param');
    }
    const qrValue = qrValuePart.split('=')[1];
    
    // Assuming standard structure relative to end
    const qrProduct = pathParts[pathParts.length - 2];
    const qrOem = pathParts[pathParts.length - 3];
    const qrState = pathParts[pathParts.length - 4];

    if (!qrState || !qrOem || !qrProduct) {
        throw new BadRequestException('Invalid QR Code Format: Missing State/OEM/Product in URL');
    }

    // 2. State Authorization Validation
    if (!isSuperAdmin) {
        if (authorizedState && authorizedState !== qrState) {
             throw new BadRequestException(`Invalid QR Code: You are not authorized for State ${qrState}`);
        }
    }

    // 3. Brand (OEM) Validation
    if (!isSuperAdmin) {
        // For Dealers, strict check against authorized OEMs list
        if (user.role === 'DEALER_USER' || user.role === 'DEALER') {
             if (!authorizedOems.includes(qrOem)) {
                 throw new BadRequestException(`Invalid QR Code: You are not authorized for Brand ${qrOem}`);
             }
        } else {
             // For System Users (e.g. OEM Admin)
             if (authorizedOems.length > 0 && !authorizedOems.includes(qrOem)) {
                  throw new BadRequestException(`Invalid QR Code: You are not authorized for Brand ${qrOem}`);
             }
        }
    }

    // 4. QR Serial Validation (Existence)
    // Validate {ENCRYPTED_UNIQUE_SERIAL} -> We use 'value' as the unique identifier
    const qrCode = await this.prisma.qRCode.findUnique({
      where: { value: qrValue },
      include: {
        batch: {
          include: {
            oem: true,
            state: true,
            product: true
          }
        }
      }
    });

    if (!qrCode) {
      throw new NotFoundException('QR Code not found (Invalid Serial)');
    }

    // Extra Safety: Verify that the URL metadata matches the DB Record
    if (qrCode.batch.state.code !== qrState) {
        throw new BadRequestException('Security Alert: QR State code does not match database record');
    }
    if (qrCode.batch.oem.code !== qrOem) {
        throw new BadRequestException('Security Alert: QR Brand code does not match database record');
    }

    if (qrCode.status !== 0) {
      throw new BadRequestException('QR Code already used');
    }

    // If all checks pass:
    return {
      success: true,
      data: {
        id: qrCode.id,
        serialNumber: qrCode.serialNumber,
        value: qrCode.value,
        oem: qrCode.batch.oem.name,
        state: qrCode.batch.state.name,
        stateCode: qrCode.batch.state.code,
        product: qrCode.batch.product.name,
        batchId: qrCode.batch.batchId
      }
    };
  }

  async validateQrByValue(qrValue: string, user: any) {
    let dbUser: any = null;
    let authorizedState: string | null = null;
    let authorizedOems: string[] = [];
    let isSuperAdmin = false;

    if (user.role === 'DEALER_USER' || user.role === 'DEALER') {
        dbUser = await this.prisma.dealer.findUnique({
            where: { id: user.userId },
            include: { oems: true }
        });
        if (!dbUser) throw new UnauthorizedException('Dealer account not found');
        if (dbUser.status !== 'ACTIVE') throw new UnauthorizedException('Dealer account is inactive');
        
        authorizedState = dbUser.stateCode;
        authorizedOems = dbUser.oems.map(o => o.code);
    } else {
        dbUser = await this.prisma.user.findUnique({ where: { id: user.userId } });
        if (!dbUser) throw new UnauthorizedException('User account not found');
        
        if (dbUser.role === 'SUPER_ADMIN') {
            isSuperAdmin = true;
        } else if (dbUser.role === 'STATE_ADMIN') {
            authorizedState = dbUser.stateCode;
            if (dbUser.oemCode) authorizedOems = [dbUser.oemCode];
        } else if (dbUser.role === 'OEM_ADMIN') {
            if (dbUser.oemCode) authorizedOems = [dbUser.oemCode];
            if (dbUser.stateCode) authorizedState = dbUser.stateCode;
        }
    }

    const qrCode = await this.prisma.qRCode.findUnique({
      where: { value: qrValue },
      include: {
        batch: {
          include: {
            oem: true,
            state: true,
            product: true
          }
        }
      }
    });

    if (!qrCode) {
      throw new NotFoundException('QR Code not found (Invalid Serial)');
    }

    if (!isSuperAdmin) {
        const qrState = qrCode.batch.state.code;
        const qrOem = qrCode.batch.oem.code;
        if (authorizedState && authorizedState !== qrState) {
             throw new BadRequestException(`Invalid QR Code: You are not authorized for State ${qrState}`);
        }
        if (user.role === 'DEALER_USER' || user.role === 'DEALER') {
             if (!authorizedOems.includes(qrOem)) {
                 throw new BadRequestException(`Invalid QR Code: You are not authorized for Brand ${qrOem}`);
             }
        } else {
             if (authorizedOems.length > 0 && !authorizedOems.includes(qrOem)) {
                  throw new BadRequestException(`Invalid QR Code: You are not authorized for Brand ${qrOem}`);
             }
        }
    }

    if (qrCode.status !== 0) {
      throw new BadRequestException('QR Code already used');
    }

    return {
      success: true,
      data: {
        id: qrCode.id,
        serialNumber: qrCode.serialNumber,
        value: qrCode.value,
        oem: qrCode.batch.oem.name,
        state: qrCode.batch.state.name,
        stateCode: qrCode.batch.state.code,
        product: qrCode.batch.product.name,
        batchId: qrCode.batch.batchId
      }
    };
  }

  async createCertificate(data: any) {
    console.log("createCertificate called with keys:", data ? Object.keys(data) : 'null');
    console.log("createCertificate dealerId:", data.dealerId);
    
    // Handle potential flat structure from frontend
    const qrValue = data.qrValue;
    const locationText = data.locationText || '';
    const systemLogo = data.systemLogo;
    const systemName = data.systemName;
    const dealerId = data.dealerId || null;
    const qrCodeImageBase64 = data.qrCodeImage;

    const vehicleDetails = data.vehicleDetails || {
        vehicleMake: data.vehicleMake,
        vehicleCategory: data.vehicleCategory,
        fuelType: data.fuelType,
        passingRto: data.passingRto,
        registrationRto: data.registrationRto,
        series: data.series,
        manufacturingYear: data.manufacturingYear,
        chassisNo: data.chassisNo,
        engineNo: data.engineNo
    };

    const ownerDetails = data.ownerDetails || {
        ownerName: data.ownerName,
        ownerContact: data.ownerContact
    };

    let dealerDetails: { name: string; tradeCertificateNo: string; gstNo: string; tradeValidity: string | null } = {
        name: 'NA',
        tradeCertificateNo: 'NA',
        gstNo: 'NA',
        tradeValidity: null
    };

    if (dealerId) {
        console.log("Fetching dealer details for ID:", dealerId);
        const dealer = await this.prisma.dealer.findUnique({ where: { id: dealerId } });
        if (dealer) {
            console.log("Dealer found:", dealer.name);
            dealerDetails = {
                name: dealer.name,
                tradeCertificateNo: dealer.tradeCertificateNo || 'NA',
                gstNo: dealer.gstNo || 'NA',
                tradeValidity: dealer.tradeValidity ? dealer.tradeValidity.toISOString() : null
            };
        } else {
            console.log("Dealer not found for ID:", dealerId);
        }
    } else if (data.dealerDetails) {
        console.log("Using provided dealerDetails from payload");
        dealerDetails = {
            name: data.dealerDetails.name || 'NA',
            tradeCertificateNo: data.dealerDetails.tradeCertificateNo || 'NA',
            gstNo: data.dealerDetails.gstNo || 'NA',
            tradeValidity: data.dealerDetails.tradeValidity || null
        };
    }
    
    console.log("Final Dealer Details for PDF:", dealerDetails);

    const photos = data.photos || {
        photoFrontLeft: data.photoFrontLeft,
        photoBackRight: data.photoBackRight,
        photoNumberPlate: data.photoNumberPlate,
        photoRc: data.photoRc
    };

    if (!qrValue || !vehicleDetails || !ownerDetails || !photos) {
        throw new BadRequestException('Missing required fields: qrValue, vehicleDetails, ownerDetails, or photos');
    }

    // 1. Fetch QR and related data
    const qrCode = await this.prisma.qRCode.findUnique({
      where: { value: qrValue },
      include: {
        batch: {
          include: {
            oem: true,
            state: true,
            product: true
          }
        }
      }
    });

    if (!qrCode) throw new NotFoundException('QR Code not found');
    if (qrCode.status !== 0) throw new BadRequestException('QR Code already used');

    // If system branding not provided from client, load from SystemSettings
    let finalSystemName = systemName;
    let finalSystemLogo = systemLogo;
    if (!finalSystemName || !finalSystemLogo) {
        const settings = await this.prisma.systemSettings.findUnique({
            where: { id: 'SYSTEM_SETTINGS' }
        });
        if (settings) {
            if (!finalSystemName) finalSystemName = settings.systemName;
            if (!finalSystemLogo && settings.systemLogo) finalSystemLogo = settings.systemLogo;
        }
    }

    // 2. Generate Certificate Number
    // Format: {passingRto}{value} as requested
    const certNumber = `${vehicleDetails.passingRto}${qrCode.value}`;

    // 3. Define Paths
    const stateCode = qrCode.batch.state.code;
    const oemCode = qrCode.batch.oem.code;
    const productCode = qrCode.batch.product.code;
    
    // QR Content: {Base URL}/{STATE}/{OEM}/{MATERIAL}/qr={VALUE}
    const baseUrl = process.env.BASE_URL || 'https://smartvahan.com';
    const qrContent = `${baseUrl}/${stateCode}/${oemCode}/${productCode}/qr=${qrCode.value}`;

    // Uploads structure: uploads/{STATE}/{OEM}/{PRODUCT}/
    const baseUploadDir = path.join(process.cwd(), 'uploads', stateCode, oemCode, productCode);
    if (!fs.existsSync(baseUploadDir)) {
      fs.mkdirSync(baseUploadDir, { recursive: true });
    }

    // 4. Save Images
    const saveImage = (base64Data: string, name: string) => {
      try {
        if (!base64Data) {
            console.error(`Missing base64 data for ${name}`);
            return null;
        }
        const matches = base64Data.match(/^data:([A-Za-z-+\/]+);base64,(.+)$/);
        if (!matches || matches.length !== 3) {
            console.error(`Invalid base64 format for ${name}`);
            return null;
        }
        
        const buffer = Buffer.from(matches[2], 'base64');
        const filename = `${certNumber}_${name}.jpg`;
        const filepath = path.join(baseUploadDir, filename);
        fs.writeFileSync(filepath, buffer);
        return filepath; 
      } catch (e) {
        console.error(`Error saving image ${name}:`, e);
        throw e;
      }
    };

    try {
        const photoPaths = {
            photoFrontLeft: saveImage(photos.photoFrontLeft, 'FrontLeft'),
            photoBackRight: saveImage(photos.photoBackRight, 'BackRight'),
            photoNumberPlate: saveImage(photos.photoNumberPlate, 'NumberPlate'),
            photoRc: saveImage(photos.photoRc, 'RC')
        };
        
        // Generate QR Code Image from value (Ensure it exists and is high quality)
        let qrCodeImagePath = null;
        try {
            const qrFilename = `${certNumber}_QR.png`;
            qrCodeImagePath = path.join(baseUploadDir, qrFilename);
            await QRCode.toFile(qrCodeImagePath, qrContent, {
                width: 300,
                margin: 2,
                color: {
                    dark: '#000000',
                    light: '#FFFFFF'
                }
            });
        } catch (e) {
            console.error("Failed to generate QR Code image:", e);
        }

        // Check if any image failed (returned null) - this would cause Prisma error
        if (!photoPaths.photoFrontLeft || !photoPaths.photoBackRight || !photoPaths.photoNumberPlate || !photoPaths.photoRc) {
            throw new InternalServerErrorException("Failed to save one or more images. Invalid format.");
        }

        // 5. Generate PDF
        const pdfFilename = `${certNumber}.pdf`;
        const pdfPath = path.join(baseUploadDir, pdfFilename);
        
        await this.generatePdf(pdfPath, {
            certNumber,
            qrCode,
            vehicleDetails,
            ownerDetails,
            photos: photoPaths,
            locationText,
            generatedAt: new Date(),
            systemLogo: finalSystemLogo,
            systemName: finalSystemName,
            qrCodeImagePath,
            dealerName: dealerDetails.name,
            tradeCertificateNo: dealerDetails.tradeCertificateNo,
            gstNo: dealerDetails.gstNo,
            tradeValidity: dealerDetails.tradeValidity
                ? new Date(dealerDetails.tradeValidity).toLocaleDateString('en-IN')
                : ''
        });

        // 6. Save to DB
        const vehicleNumber = `${vehicleDetails.registrationRto}${vehicleDetails.series}`;
        
        // Always 1 as per requirement (one vehicle can have multiple certificates)
        const count = 1;

        console.log("Starting Transaction for Certificate Creation...");

        // Use transaction to update QR status and create certificate
        const cert = await this.prisma.$transaction(async (tx) => {
            await tx.qRCode.update({
            where: { id: qrCode.id },
            data: { status: 1 }
            });

            return await tx.certificate.create({
            data: {
                certificateNumber: certNumber,
                qrCodeId: qrCode.id,
                vehicleMake: vehicleDetails.vehicleMake,
                vehicleCategory: vehicleDetails.vehicleCategory,
                fuelType: vehicleDetails.fuelType,
                passingRto: vehicleDetails.passingRto,
                registrationRto: vehicleDetails.registrationRto,
                series: vehicleDetails.series,
                manufacturingYear: vehicleDetails.manufacturingYear,
                chassisNumber: vehicleDetails.chassisNo,
                engineNumber: vehicleDetails.engineNo,
                ownerName: ownerDetails.ownerName,
                ownerContact: ownerDetails.ownerContact,
                photoFrontLeft: photoPaths.photoFrontLeft!, // Non-null assertion safe due to check above
                photoBackRight: photoPaths.photoBackRight!,
                photoNumberPlate: photoPaths.photoNumberPlate!,
                photoRc: photoPaths.photoRc!,
                pdfPath: pdfPath,
                locationText: locationText,
                vehicleNumber: vehicleNumber,
                count: count
            }
            });
        });

        return {
            success: true,
            message: 'Certificate Generated Successfully',
            pdfUrl: `/uploads/${stateCode}/${oemCode}/${productCode}/${pdfFilename}`,
            certificateId: cert.id
        };
    } catch (error) {
        console.error("Error in createCertificate:", error);
        fs.appendFileSync(path.join(process.cwd(), 'create_cert_error.log'), `${new Date().toISOString()} - ${error.message}\n${error.stack}\n\n`);
        throw new InternalServerErrorException("Failed to generate certificate: " + (error.message || error));
    }
  }

  private async generatePdf(outputPath: string, data: any) {
    return new Promise((resolve, reject) => {
      const doc = new PDFDocument({ size: 'A4', margin: 20 });
      const stream = fs.createWriteStream(outputPath);
      doc.pipe(stream);

      const startX = 20;
      let currentY = 20;
      const fullWidth = 555; // A4 (595) - 40 margin
      const contentWidth = fullWidth;

      // --- Helper Functions ---
      const resolveLogoPath = (logo: string) => {
        let value = logo;
        if (value.startsWith('http://') || value.startsWith('https://')) {
          try {
            const url = new URL(value);
            value = url.pathname || value;
          } catch {
          }
        }
        if (value.startsWith('/uploads') || value.startsWith('uploads')) {
          return path.join(process.cwd(), value.startsWith('/') ? value.substring(1) : value);
        }
        return null;
      };

      const drawGreyHeader = (text: string, y: number) => {
        doc.rect(startX, y, contentWidth, 20).fill('#E0E0E0');
        doc.fillColor('black').font('Helvetica-Bold').fontSize(10)
           .text(text, startX, y + 5, { align: 'center', width: contentWidth });
        return y + 25;
      };

      const drawField = (label: string, value: string, x: number, y: number, w: number, isBoldValue = true) => {
        // Label
        doc.fillColor('black').font('Helvetica').fontSize(9)
           .text(label.toUpperCase(), x, y, { width: w * 0.4, align: 'left' });
        // Colon
        doc.text(':', x + (w * 0.4), y, { width: 10, align: 'center' });
        // Value
        const val = value ? String(value).toUpperCase() : '-';
        doc.font(isBoldValue ? 'Helvetica-Bold' : 'Helvetica')
           .text(val, x + (w * 0.4) + 10, y, { width: (w * 0.6) - 10, align: 'left' });
      };

      // ================= HEADER =================
      doc.rect(startX, currentY, contentWidth, 160).fill('#E0E0E0');
      
      // OEM Logo (Left)
      if (data.qrCode.batch.oem.logo) {
          try {
              const logo = data.qrCode.batch.oem.logo;
              const fsPath = resolveLogoPath(logo);
              if (fsPath) {
                   doc.image(fsPath, startX + 10, currentY + 10, { fit: [140, 140], align: 'center', valign: 'center' });
              } else {
                  let logoData = logo;
                  if (logoData.startsWith('data:')) logoData = logoData.split(',')[1];
                  doc.image(Buffer.from(logoData, 'base64'), startX + 10, currentY + 10, { fit: [140, 140], align: 'center', valign: 'center' });
              }
          } catch (e) {
               console.error("OEM Logo Error", e);
          }
      }

      // Center Text
      const centerX = startX;
      doc.fillColor('black');
      doc.font('Helvetica-Bold').fontSize(16).text('INSTALLATION CERTIFICATE', centerX, currentY + 35, { align: 'center', width: contentWidth });
      // Base URL or System Name
      doc.fontSize(11).text((data.systemName || 'SMART VAHAN').toUpperCase(), centerX, currentY + 58, { align: 'center', width: contentWidth });
      // Registration RTO Series (Title/Number)
      const rtoSeries = `${data.vehicleDetails.registrationRto}-${data.vehicleDetails.series}`.toUpperCase(); 
      doc.fontSize(13).text(rtoSeries, centerX, currentY + 80, { align: 'center', width: contentWidth });

      // System Logo (Right)
      if (data.systemLogo) {
          try {
              const fsPath = resolveLogoPath(data.systemLogo);
              if (fsPath) {
                doc.image(fsPath, startX + contentWidth - 150, currentY + 10, { width: 140, height: 140, align: 'center', valign: 'center' });
              } else {
                let sysLogoData = data.systemLogo;
                if (sysLogoData.startsWith('data:')) sysLogoData = sysLogoData.split(',')[1];
                doc.image(Buffer.from(sysLogoData, 'base64'), startX + contentWidth - 150, currentY + 10, { width: 140, height: 140, align: 'center', valign: 'center' });
              }
          } catch (e) {
               console.error("System Logo Error", e);
          }
      }

      currentY += 170;

      // Note Sub-header
      doc.font('Helvetica-Oblique').fontSize(8)
         .text(`NOTE: THIS INSTALLATION CERTIFICATE IS ONLY VALID IN THE STATE OF ${data.qrCode.batch.state.name.toUpperCase()}`, 
               startX, currentY, { align: 'center', width: contentWidth });
      currentY += 15;

      // ================= MAIN INFO BLOCK =================
      const qrColWidth = 130;
      const textColWidth = contentWidth - qrColWidth;
      const rowHeight = 16;
      let infoY = currentY;

      // QR Code (Left)
      if (data.qrCodeImagePath) {
          try {
             // 120x120 QR Code
             doc.image(data.qrCodeImagePath, startX, infoY + 10, { fit: [100, 100], align: 'center' });
             doc.font('Helvetica-Oblique').fontSize(8)
                .text('(Scan To Verify)', startX, infoY + 115, { width: 100, align: 'center' });
          } catch (e) {
              console.error("QR Image Error", e);
              doc.text('QR Error', startX, infoY + 50);
          }
      } else {
           doc.text('No QR Image', startX, infoY + 50);
      }

      // Text Fields (Right)
      // Fields: COP, COP Validity, Certificate No, QR Serial, Date Gen, Gen At, Valid From, Valid Till, Vehicle No
      const validFrom = new Date(data.generatedAt).toLocaleDateString('en-IN');
      const validTill = new Date(new Date(data.generatedAt).setFullYear(new Date(data.generatedAt).getFullYear() + 1)).toLocaleDateString('en-IN');
      // Vehicle Number in image seems to be date?? But we use Reg No.
      const vehicleNumber = `${data.vehicleDetails.registrationRto}${data.vehicleDetails.series}`; // Or reg number logic

      const copDoc = data.qrCode.batch.oem.copDocument || '-';
      const copVal = data.qrCode.batch.oem.copValidity 
        ? new Date(data.qrCode.batch.oem.copValidity).toLocaleDateString('en-IN') 
        : '-';

      // Clean Location Text (Remove Lat/Long)
      let locationDisplay = data.locationText || '';
      if (locationDisplay.includes('|')) {
          locationDisplay = locationDisplay.split('|')[0].trim();
      }
      if (locationDisplay.startsWith('Lat:')) {
          locationDisplay = ''; 
      }

      const infoFields = [
          ['COP', copDoc], 
          ['COP VALIDITY', copVal],
          ['CERTIFICATE NUMBER', data.certNumber], // {passingRto}{value} passed as certNumber
          ['QR CODE SERIAL NUMBER', data.qrCode.serialNumber],
          ['DATE OF GENERATION', new Date(data.generatedAt).toLocaleDateString('en-IN')],
          ['GENERATED AT', locationDisplay],
          ['VALID FROM', validFrom],
          ['VALID TILL', validTill],
          ['VEHICLE NUMBER', vehicleNumber]
      ];

      infoFields.forEach((field, i) => {
          drawField(field[0], field[1], startX + qrColWidth, infoY + (i * rowHeight), textColWidth);
      });

      currentY += (infoFields.length * rowHeight) + 10;

      // ================= MATERIAL DETAILS =================
      currentY = drawGreyHeader('MATERIAL DETAILS', currentY);
      
      // Single Row: Brand | Product | Quantity
      const matY = currentY + 5;
      const colW = contentWidth / 3;
      
      // Brand
      doc.font('Helvetica').fontSize(9).text('BRAND', startX + 5, matY);
      doc.font('Helvetica-Bold').text(`: ${data.qrCode.batch.oem.name.toUpperCase()}`, startX + 50, matY);

      // Product
      doc.font('Helvetica').text('PRODUCT', startX + colW + 5, matY);
      doc.font('Helvetica-Bold').text(`: ${data.qrCode.batch.product.name.toUpperCase()}`, startX + colW + 50, matY);

      // Quantity
      let quantityText = `${data.qrCode.batch.quantity || 1}`;
      const pCode = data.qrCode.batch.product.code ? data.qrCode.batch.product.code.toUpperCase() : '';
      if (pCode === 'C3') quantityText = 'Set of 2';
      else if (pCode === 'C4') quantityText = 'Set of 2';
      else if (pCode === 'CT') quantityText = '4 (2Y,1W,1R)';
      else if (pCode === 'CTAUTO') quantityText = '4 (2Y,1W,1R)';

      doc.font('Helvetica').text('QUANTITY', startX + (colW * 2) + 5, matY);
      doc.font('Helvetica-Bold').text(`: ${quantityText.toUpperCase()}`, startX + (colW * 2) + 50, matY);
      
      currentY += 25;

      // ================= VEHICLE DETAILS =================
      currentY = drawGreyHeader('VEHICLE DETAILS', currentY);
      
      const vY = currentY + 5;
      const vRowH = 18;
      const vColW = contentWidth / 2;

      const vLeft = [
          ['OWNER NAME', data.ownerDetails.ownerName],
          ['VEHICLE MAKE', data.vehicleDetails.vehicleMake],
          ['CHASSIS NUMBER', data.vehicleDetails.chassisNo],
          ['YEAR OF MANUFACTURING', data.vehicleDetails.manufacturingYear]
      ];
      
      const vRight = [
          ['OWNER PHONE', data.ownerDetails.ownerContact],
          ['VEHICLE CATEGORY', data.vehicleDetails.vehicleCategory],
          ['ENGINE NUMBER', data.vehicleDetails.engineNo],
          ['', '']
      ];

      for (let i = 0; i < vLeft.length; i++) {
          // Left Field
          drawField(vLeft[i][0], vLeft[i][1], startX, vY + (i * vRowH), vColW);
          // Right Field
          if (vRight[i][0]) {
             drawField(vRight[i][0], vRight[i][1], startX + vColW, vY + (i * vRowH), vColW);
          }
      }
      
      currentY += (vLeft.length * vRowH) + 10;

      // ================= FITMENT PHOTOGRAPHS =================
      currentY = drawGreyHeader('FITMENT PHOTOGRAPHS', currentY);
      currentY += 10;

      // 4 Photos in a row
      const photoGap = 10;
      const photoW = (contentWidth - (photoGap * 3)) / 4;
      // Increased photo size by 1.5x height roughly (was 100)
      const photoH = 150; 

      const photos = [
          { img: data.photos.photoFrontLeft, label: 'FRONT LEFT IMAGE' },
          { img: data.photos.photoBackRight, label: 'BACK RIGHT IMAGE' },
          { img: data.photos.photoNumberPlate, label: 'NUMBER PLATE IMAGE' },
          { img: data.photos.photoRc, label: 'DOCUMENT IMAGE' }
      ];

      photos.forEach((p, i) => {
          const px = startX + (i * (photoW + photoGap));
          if (p.img) {
              try {
                 doc.image(p.img, px, currentY, { fit: [photoW, photoH], align: 'center' });
              } catch (e) {
                  doc.rect(px, currentY, photoW, photoH).stroke();
                  doc.text('Img Error', px + 5, currentY + 40);
              }
          } else {
              doc.rect(px, currentY, photoW, photoH).stroke();
              doc.text('No Image', px + 5, currentY + 40);
          }
          doc.font('Helvetica-Bold').fontSize(7)
             .text(p.label, px, currentY + photoH + 5, { width: photoW, align: 'center' });
      });

      currentY += photoH + 20;

      // ================= DEALER DETAILS =================
      currentY = drawGreyHeader('DEALER DETAILS', currentY);
      const dY = currentY + 5;
      
      // Need Dealer Info. Assuming passed in data or placeholders.
      // If not in data, use placeholders.
      const dealerName = (data.dealerName ?? 'NA'); 
      const tradeCert = (data.tradeCertificateNo ?? 'NA');
      const gstNo = (data.gstNo ?? 'NA');
      const tradeValidity = (data.tradeValidity ?? 'NA');
      console.log('PDF Dealer Section Values:', { dealerName, tradeCert, gstNo, tradeValidity });
      
      // Row 1
      drawField('RTO LOCATION', data.vehicleDetails.passingRto, startX, dY, vColW);
      drawField('DEALER NAME', dealerName, startX + vColW, dY, vColW);
      
      // Row 2
      drawField('TRADE CERTIFICATE', tradeCert, startX, dY + vRowH, vColW);
      drawField('TRADE VALIDITY', tradeValidity, startX + vColW, dY + vRowH, vColW);

      // Row 3
      drawField('GSTIN', gstNo, startX, dY + (vRowH * 2), vColW);

      currentY += (vRowH * 3) + 20;

      // ================= FOOTER =================
      doc.font('Helvetica-Bold').fontSize(9).text('DECLARATION:', startX, currentY);
      currentY += 10;
      doc.font('Helvetica').fontSize(8)
         .text('We hereby certify that we have supplied/installed the ARAI approved RRT as per the CMVR rule no 104/104D specified under CMVR GSR 784 (E) 291 (E).', startX, currentY, { width: contentWidth * 0.7 });

      // Dealer Stamp Box (Right)
      const stampBoxSize = 60;
      // doc.rect(startX + contentWidth - stampBoxSize - 10, currentY - 10, stampBoxSize, stampBoxSize).stroke();
      doc.font('Helvetica-Bold').text('(DEALER STAMP & SIGN)', startX + contentWidth - 150, currentY + 30, { width: 150, align: 'center' });
      // doc.rect(startX + contentWidth - 40, currentY + 20, 20, 20).stroke(); // REMOVED overlapping box

      doc.end();
      stream.on('finish', () => resolve(outputPath));
      stream.on('error', reject);
    });
  }
}
